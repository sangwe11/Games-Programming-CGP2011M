#version 330 core

in vec2 uvIn;
in vec4 posPos;

uniform sampler2D sceneTexture;
uniform vec2 inverseTextureSize;
uniform float fxaaSpanMax;
uniform float fxaaReduceMin;
uniform float fxaaReduceMul;

void main()
{
	vec3 finalColor;
	
	// Sample pixels in X pattern
	//vec3 rgbTopLeft = texture(sceneTexture, uvIn + (vec2(-1.0, -1.0) * inverseTextureSize)).xyz;
	//vec3 rgbTopRight = texture(sceneTexture, uvIn + (vec2(1.0, -1.0) * inverseTextureSize)).xyz;
	//vec3 rgbBottomLeft = texture(sceneTexture, uvIn + (vec2(-1.0, 1.0) * inverseTextureSize)).xyz;
	//vec3 rgbBottomRight = texture(sceneTexture, uvIn + (vec2(1.0, 1.0) * inverseTextureSize)).xyz;
	//vec3 rgbMiddle = texture(sceneTexture, posPos.zw).xyz;
	
	vec3 rgbTopLeft = texture(sceneTexture, posPos.zw).xyz;
	vec3 rgbTopRight = textureOffset(sceneTexture, posPos.zw, ivec2(1, 0)).xyz;
	vec3 rgbBottomLeft = textureOffset(sceneTexture, posPos.zw, ivec2(0, 1)).xyz;
	vec3 rgbBottomRight = textureOffset(sceneTexture, posPos.zw, ivec2(1, 1)).xyz;
	vec3 rgbMiddle = texture(sceneTexture, posPos.xy).xyz;
	
	// Calculate luma for each pixel
	vec3 luma = vec3(0.299, 0.587, 0.144);
	float lumaMiddle = dot(luma, rgbMiddle);
	float lumaTopLeft = dot(luma, rgbTopLeft);
	float lumaTopRight = dot(luma, rgbTopRight);
	float lumaBottomRight = dot(luma, rgbBottomRight);
	float lumaBottomLeft = dot(luma, rgbBottomLeft);
	
	// Calculate min and max luma
	float lumaMin = min(lumaMiddle, min(min(lumaTopLeft, lumaTopRight), min(lumaBottomLeft, lumaBottomRight)));
	float lumaMax = max(lumaMiddle, max(max(lumaTopLeft, lumaTopRight), max(lumaBottomLeft, lumaBottomRight)));
	
	// Calculate edge direction
	vec2 direction;
	direction.x = -((lumaTopLeft + lumaTopRight) - (lumaBottomLeft + lumaBottomRight));
	direction.y = ((lumaTopLeft + lumaBottomLeft) - (lumaTopRight + lumaBottomRight));
	
	// Reduce direction
	float directionReduce = max((lumaTopLeft + lumaTopRight + lumaBottomLeft + lumaBottomRight) * (fxaaReduceMul * 0.25), fxaaReduceMin);
	float inverseDirectionAdjustment = 1.0 / (min(abs(direction.x), abs(direction.y)) + directionReduce);
	
	// Clamp direction to fxaaSpanMax
	direction = clamp(direction * inverseDirectionAdjustment, vec2(-fxaaSpanMax, -fxaaSpanMax), vec2(fxaaSpanMax, fxaaSpanMax)) * inverseTextureSize;
	
	// Blur results
	vec3 rgbA = 0.5 * (texture(sceneTexture, posPos.xy + direction * vec2(1.0/3.0 - 0.5)).xyz + texture(sceneTexture, posPos.xy + direction * vec2(2.0/3.0 - 0.5)).xyz);
	vec3 rgbB = rgbA * (1.0 / 2.0) + (1.0 / 4.0) * (texture(sceneTexture, posPos.xy + direction * vec2(0.0/3.0 - 0.5)).xyz + texture(sceneTexture, posPos.xy + direction * vec2(3.0/3.0 - 0.5)).xyz);
	
	// Calculate luma for result2
	float lumaB = dot(rgbB, luma);
	
	// Has too much been sampled?
	if((lumaB < lumaMin) || (lumaB > lumaMax))
		finalColor = rgbA;
	else
		finalColor = rgbB;
		
	gl_FragColor = vec4(finalColor, 1.0);
}